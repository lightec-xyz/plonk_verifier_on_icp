# `plonk_verifier_on_icp`

Welcome to your new `plonk_verifier_on_icp` project and to the Internet Computer development community. By default, creating a new project adds this README and some template files to your project directory. You can edit these template files to customize your project and to include your own code to speed up the development cycle.

To get started, you might want to explore the project directory structure and the default configuration file. Working with this project in your development environment will not affect any production deployment or identity tokens.

To learn more before you start working with `plonk_verifier_on_icp`, see the following documentation available online:

- [Quick Start](https://internetcomputer.org/docs/current/developer-docs/setup/deploy-locally)
- [SDK Developer Tools](https://internetcomputer.org/docs/current/developer-docs/setup/install)
- [Rust Canister Development Guide](https://internetcomputer.org/docs/current/developer-docs/backend/rust/)
- [ic-cdk](https://docs.rs/ic-cdk)
- [ic-cdk-macros](https://docs.rs/ic-cdk-macros)
- [Candid Introduction](https://internetcomputer.org/docs/current/developer-docs/backend/candid/)

If you want to start working on your project right away, you might want to try the following commands:

```bash
cd plonk_verifier_on_icp/
dfx help
dfx canister --help
```

## Running the project locally

If you want to test your project locally, you can use the following commands:

```bash
# Starts the replica, running in the background
dfx start --background

# Deploys your canisters to the replica and generates your candid interface
dfx deploy
```

Once the job completes, your application will be available at `http://localhost:4943?canisterId={asset_canister_id}`.

If you have made changes to your backend canister, you can generate a new candid interface with

```bash
npm run generate
```

at any time. This is recommended before starting the frontend development server, and will be run automatically any time you run `dfx deploy`.

If you are making frontend changes, you can start a development server with

```bash
npm start
```

Which will start a server at `http://localhost:8080`, proxying API requests to the replica at port 4943.

### Note on frontend environment variables

If you are hosting frontend code somewhere without using DFX, you may need to make one of the following adjustments to ensure your project does not fetch the root key in production:

- set`DFX_NETWORK` to `ic` if you are using Webpack
- use your own preferred method to replace `process.env.DFX_NETWORK` in the autogenerated declarations
  - Setting `canisters -> {asset_canister_id} -> declarations -> env_override to a string` in `dfx.json` will replace `process.env.DFX_NETWORK` with the string in the autogenerated declarations
- Write your own `createActor` constructor

# What's purpose of plonk_verifier_on_icp
Plonk is a well-known ZK scheme and widely used, Gnark is a ZK libray supports gnark but it is written in Golang, Arkworks is a ZK library written in Rust, which does not support plonk, but provides some basic ZK components, such as finite field, curve, paring. In this repo, we implement rust plonk verifier based on Arkworks.

There are two challenges in building it:   
- Based on arkworks, implement the plonk verifier in rust.
- Data difference(little-endian vs big-endian,  negative Y flag) between Ganrk and Arkworks.


# Architecture 

![plonk_verifier_arch drawio](https://github.com/user-attachments/assets/77413f83-62f0-46af-a6b3-80b08460ad62)

- verifer.rs: entry of plonk verifier, call other files functions 
- vk.rs: build verification key from bytes.
- proof.rs: build proof from bytes 
- witness.rs: build witness from bytes 
- fiat_shamir.rs: implement fiat_shamir function  
- hash_to_field.rs: implement hash_to function
- fr.rs: build fr from bytes 
- point.rs: build BN254 G1/G2 point from bytes
- lib.rs: the entrance for plonk verifer, provides verify_bytes() and verify_hex() two functions.


## vk.rs 
In gnark vk, a precomputed pairing lines corresponding to G₂, [α]G₂, which costs 32768 bytes.
for saving cycles, we can use vk without lines as parameter verify_bytes or verify_hex.
```go
  type VerifyingKey struct {
    // Size circuit
    Size              uint64
    SizeInv           fr.Element
    Generator         fr.Element
    NbPublicVariables uint64

    // Commitment scheme that is used for an instantiation of PLONK
    Kzg kzg.VerifyingKey

    // cosetShift generator of the coset on the small domain
    CosetShift fr.Element

    // S commitments to S1, S2, S3
    S [3]kzg.Digest

    // Commitments to ql, qr, qm, qo, qcp prepended with as many zeroes (ones for l) as there are public inputs.
    // In particular Qk is not complete.
    Ql, Qr, Qm, Qo, Qk kzg.Digest
    Qcp                []kzg.Digest

    CommitmentConstraintIndexes []uint64
  }

  type VerifyingKey struct {
	G2    [2]bn254.G2Affine // [G₂, [α]G₂ ]
	G1    bn254.G1Affine
	Lines [2][2][len(bn254.LoopCounter)]bn254.LineEvaluationAff // precomputed pairing lines corresponding to G₂, [α]G₂
  }

```

## proof.rs 
thre are 2 types proof
- compressed, where g1 points are compressed, it is the result of proof.WriteTo
- uncompressed, where g1 points are uncompressed, it is the result of proof.MarshalSolidity()
suggest use compressed one for saving cycles


# How to run in local network 
1. start ICP locally in one terminal, 
```bash
dfx start --clean
```
2. download repo and deploy plonk verifer on icp in another terminal,
```bash
git clone https://github.com/lightec-xyz/plonk_verifier_on_icp.git
cd plonk_verifier_on_icp
dfx deploy plonk_verifier_on_icp_backend 
```
after deployed, get the cansiter id(e.g. bkyz2-fmaaa-aaaaa-qaaaq-cai) for later use
```bash
Installing canisters...
Creating UI canister on the local network.
The UI canister on the "local" network is "bd3sg-teaaa-aaaaa-qaaba-cai"
Installing code for canister plonk_verifier_on_icp_backend, with canister ID bkyz2-fmaaa-aaaaa-qaaaq-cai
Deployed canisters.
URLs:
  Backend canister via Candid interface:
    plonk_verifier_on_icp_backend: http://127.0.0.1:4943/?canisterId=bd3sg-teaaa-aaaaa-qaaba-cai&id=bkyz2-fmaaa-aaaaa-qaaaq-cai
```
3. build the one circuit(e.g. hasher) in examples directory, and execute it, which will generate verifyingkey, proof, and witness and then call verify_bytes() to verify the proof/witness.
```bash
cd examples 
go mod tidy
cd hasher
go build
./hasher -canister bkyz2-fmaaa-aaaaa-qaaaq-cai
```

# How to run in ICP mainnet 
plonk_verifer deployed at https://a4gq6-oaaaa-aaaab-qaa4q-cai.raw.icp0.io/?id=3luut-nqaaa-aaaao-qbcwa-cai. you can run the example on ICP mainnet with the following command.

```bash
cd examples 
go mod tidy
cd hasher
go build
./hasher -canister 3luut-nqaaa-aaaao-qbcwa-cai -network ic 
```
Or, just build circuit and retrieve verifyingkey, proof, and witness and input them as the following shown.
<img width="1325" alt="image" src="https://github.com/user-attachments/assets/2a0ac97d-0503-4a65-9cce-b282195636e4">







